<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAT Question Extractor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: #0066cc;
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #eee;
            transition: all 0.3s ease;
        }

        .upload-section.hidden {
            display: none;
        }

        .upload-area {
            border: 2px dashed #0066cc;
            border-radius: 8px;
            padding: 40px;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: #0052a3;
            background: #e6f3ff;
            transform: translateY(-1px);
        }

        .upload-area.dragover {
            border-color: #0052a3;
            background: #d1e7ff;
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 4em;
            color: #0066cc;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            background: #0052a3;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.3);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0066cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results {
            display: none;
            padding: 40px;
        }

        .exam-mode-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        .exam-mode-btn:hover {
            background: #0052a3;
        }

        .exam-interface {
            display: none;
            background: white;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .exam-header {
            background: #f8f9fa;
            padding: 15px 30px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .exam-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
        }

        .question-counter {
            font-size: 1em;
            color: #666;
        }

        .timer {
            font-size: 1em;
            color: #0066cc;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timer-toggle {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            color: #666;
        }

        .timer-toggle:hover {
            background: #e6f3ff;
            color: #0066cc;
        }

        .timer-toggle.active {
            color: #0066cc;
            background: #e6f3ff;
        }

        .timer-display {
            font-weight: 600;
        }

        .exam-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 30px;
            line-height: 1.6;
            position: relative;
        }

        .annotation-tools {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }

        .annotation-tools.show {
            display: block;
        }

        .annotation-btn {
            background: none;
            border: none;
            padding: 8px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }

        .annotation-btn:hover {
            background: #e6f3ff;
        }

        .annotation-btn.active {
            background: #0066cc;
            color: white;
        }

        .highlight-yellow {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-green {
            background: #d4edda;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-blue {
            background: #d1ecf1;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-pink {
            background: #f8d7da;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .note-marker {
            background: #ffc107;
            color: #333;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 5px;
            cursor: pointer;
        }

        .note-popup {
            position: absolute;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            max-width: 300px;
            display: none;
        }

        .note-textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            resize: vertical;
        }

        .note-actions {
            margin-top: 10px;
            text-align: right;
        }

        .note-save, .note-delete {
            background: #0066cc;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
            font-size: 0.9em;
        }

        .note-delete {
            background: #dc3545;
        }

        .annotation-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,102,204,0.3);
            z-index: 999;
            transition: all 0.3s ease;
        }

        .annotation-toggle:hover {
            background: #0052a3;
            transform: scale(1.1);
        }

        .annotation-toggle.active {
            background: #28a745;
        }

        /* Question Navigator Styles */
        .question-navigator {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
            width: 200px;
        }

        .navigator-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .question-nav-btn {
            width: 30px;
            height: 30px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .question-nav-btn:hover {
            background: #f8f9fa;
            border-color: #0066cc;
        }

        .question-nav-btn.current {
            background: #0066cc;
            color: white;
            border-color: #0066cc;
        }

        .question-nav-btn.answered {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .question-nav-btn.marked {
            background: #ffc107;
            color: #333;
            border-color: #ffc107;
            position: relative;
        }

        .question-nav-btn.marked::after {
            content: "⭐";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 0.7em;
        }

        .navigator-toggle {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,102,204,0.3);
            z-index: 999;
            transition: all 0.3s ease;
        }

        .navigator-toggle:hover {
            background: #0052a3;
            transform: scale(1.1);
        }

        .exam-controls {
            margin-top: 40px;
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid #dee2e6;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-btn {
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .next-btn-new {
            background: #0066cc;
            color: white;
        }

        .next-btn-new:hover {
            background: #0052a3;
            transform: translateY(-1px);
        }

        .mark-review-btn {
            background: #ffc107;
            color: #333;
        }

        .mark-review-btn:hover {
            background: #e0a800;
            transform: translateY(-1px);
        }

        .mark-review-btn.marked {
            background: #28a745;
            color: white;
        }

        .previous-btn {
            background: #6c757d;
            color: white;
        }

        .previous-btn:hover {
            background: #545b62;
            transform: translateY(-1px);
        }

        .finish-btn-new {
            background: #dc3545;
            color: white;
        }

        .finish-btn-new:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .navigator-legend {
            margin-top: 15px;
            font-size: 0.8em;
            color: #666;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #dee2e6;
        }

        .legend-current { background: #0066cc; }
        .legend-answered { background: #28a745; }
        .legend-marked { background: #ffc107; }
        .legend-unanswered { background: white; }

        .question-section {
            margin-bottom: 30px;
        }

        .question-text {
            font-size: 1.1em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.7;
        }

        .answer-choices {
            margin: 25px 0;
        }

        .choice-option {
            display: flex;
            align-items: flex-start;
            margin: 15px 0;
            padding: 12px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .choice-option:hover {
            background: #f8f9fa;
            border-color: #0066cc;
        }

        .choice-option.selected {
            background: #e6f3ff;
            border-color: #0066cc;
        }

        .choice-option.correct {
            background: #d4edda;
            border-color: #28a745;
        }

        .choice-option.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
        }

        .choice-letter {
            font-weight: 600;
            margin-right: 15px;
            min-width: 20px;
            color: #333;
        }

        .choice-text {
            flex: 1;
            color: #333;
        }

        .result-indicator {
            margin-left: 10px;
            font-weight: 600;
        }

        .result-indicator.correct {
            color: #28a745;
        }

        .result-indicator.incorrect {
            color: #dc3545;
        }

        .explanation-section {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #0066cc;
            border-radius: 4px;
        }

        .explanation-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .explanation-text {
            color: #555;
            line-height: 1.6;
        }

        .exam-controls {
            margin-top: 40px;
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid #dee2e6;
        }

        .next-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            display: none;
        }

        .next-btn:hover {
            background: #0052a3;
        }

        .finish-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            display: none;
        }

        .finish-btn:hover {
            background: #218838;
        }

        .exam-results {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .score-display {
            font-size: 3em;
            font-weight: bold;
            color: #0066cc;
            margin: 20px 0;
        }

        .score-breakdown {
            margin: 30px 0;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .score-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 10px;
            min-width: 120px;
        }

        .score-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }

        .exam-mode-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }

        .exam-mode-btn:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.4);
        }

        .exam-interface {
            display: none;
            background: white;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .exam-header {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .exam-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }

        .exam

        .question-card {
            background: #fff;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            margin-bottom: 30px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .question-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .question-header {
            background: #0066cc;
            color: white;
            padding: 20px;
            font-weight: 600;
        }

        .question-content {
            padding: 25px;
        }

        .question-text {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #333;
        }

        .choices {
            margin: 20px 0;
        }

        .choice {
            padding: 12px 15px;
            margin: 8px 0;
            border-radius: 8px;
            background: #f8f9fa;
            border-left: 4px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .choice.correct {
            background: #d4edda;
            border-left-color: #28a745;
            font-weight: 600;
        }

        .answer-section {
            background: #f8f9fa;
            padding: 20px;
            border-top: 1px solid #e9ecef;
        }

        .answer-label {
            font-weight: 600;
            color: #28a745;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .explanation {
            background: #e6f3ff;
            padding: 20px;
            border-radius: 4px;
            border-left: 4px solid #0066cc;
            margin-top: 15px;
        }

        .explanation-label {
            font-weight: 600;
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .difficulty-easy {
            background: #d4edda;
            color: #155724;
        }

        .difficulty-medium {
            background: #fff3cd;
            color: #856404;
        }

        .difficulty-hard {
            background: #f8d7da;
            color: #721c24;
        }

        .stats {
            background: #0066cc;
            color: white;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
            text-align: center;
        }

        .stats h3 {
            margin-bottom: 10px;
            font-size: 1.5em;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin: 20px;
            border-left: 4px solid #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SAT Question Extractor</h1>
            <p>Upload your SAT question bank PDF and extract questions, answers, and explanations</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📄</div>
                <div class="upload-text">Drop your PDF file here or click to browse</div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
                <input type="file" id="fileInput" class="file-input" accept=".pdf" onchange="handleFile(this.files[0])">
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing PDF... Please wait</p>
        </div>

        <div class="results" id="results"></div>

        <div class="exam-interface" id="examInterface">
            <div class="exam-header">
                <div class="exam-title">SAT Reading and Writing</div>
                <div class="question-counter" id="questionCounter">Question 1 of 30</div>
                <div class="timer" id="timer">
                    <button class="timer-toggle" id="timerToggle" onclick="toggleTimer()" title="Toggle Timer">⏱️</button>
                    <span class="timer-display" id="timerDisplay">35:00</span>
                </div>
            </div>

            <!-- Question Navigator -->
            <div class="question-navigator" id="questionNavigator" style="display: none;">
                <div class="navigator-title">Questions</div>
                <div class="question-grid" id="questionGrid"></div>
                <div class="navigator-legend">
                    <div class="legend-item">
                        <div class="legend-color legend-current"></div>
                        <span>Current</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-answered"></div>
                        <span>Answered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-marked"></div>
                        <span>Marked</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-unanswered"></div>
                        <span>Not Answered</span>
                    </div>
                </div>
            </div>

            <!-- Navigator Toggle Button -->
            <button class="navigator-toggle" id="navigatorToggle" onclick="toggleNavigator()" title="Question Navigator">🧭</button>
            
            <div class="exam-content">
                <div class="question-section">
                    <div class="question-text" id="examQuestionText"></div>
                    
                    <div class="answer-choices" id="examChoices"></div>
                    
                    <div class="explanation-section" id="explanationSection">
                        <div class="explanation-title">Explanation:</div>
                        <div class="explanation-text" id="explanationText"></div>
                    </div>
                </div>
                
                <div class="exam-controls">
                    <button class="control-btn previous-btn" id="previousBtn" onclick="previousQuestion()">◀ Previous</button>
                    <button class="control-btn mark-review-btn" id="markReviewBtn" onclick="toggleMarkForReview()">Mark for Review</button>
                    <button class="control-btn next-btn-new" id="nextBtnNew" onclick="nextQuestionNew()">Next ▶</button>
                    <button class="control-btn finish-btn-new" id="finishBtnNew" onclick="finishExam()" style="display: none;">Finish Exam</button>
                </div>
            </div>

            <!-- Annotation Tools -->
            <div class="annotation-tools" id="annotationTools">
                <button class="annotation-btn" onclick="setAnnotationMode('highlight-yellow')" title="Yellow Highlight">🟡</button>
                <button class="annotation-btn" onclick="setAnnotationMode('highlight-green')" title="Green Highlight">🟢</button>
                <button class="annotation-btn" onclick="setAnnotationMode('highlight-blue')" title="Blue Highlight">🔵</button>
                <button class="annotation-btn" onclick="setAnnotationMode('highlight-pink')" title="Pink Highlight">🩷</button>
                <button class="annotation-btn" onclick="setAnnotationMode('note')" title="Add Note">📝</button>
                <button class="annotation-btn" onclick="clearAnnotations()" title="Clear All">🗑️</button>
            </div>

            <!-- Annotation Toggle Button -->
            <button class="annotation-toggle" id="annotationToggle" onclick="toggleAnnotationTools()" title="Toggle Annotation Tools">✏️</button>

            <!-- Note Popup -->
            <div class="note-popup" id="notePopup">
                <div style="margin-bottom: 10px; font-weight: 600;">Add Note:</div>
                <textarea class="note-textarea" id="noteTextarea" placeholder="Type your note here..."></textarea>
                <div class="note-actions">
                    <button class="note-save" onclick="saveNote()">Save</button>
                    <button class="note-delete" onclick="cancelNote()">Cancel</button>
                </div>
            </div>
            
            <div class="exam-results" id="examResults">
                <h2>Your SAT Score</h2>
                <div class="score-display" id="finalScore">720</div>
                <div class="score-breakdown">
                    <div class="score-item">
                        <div class="score-label">Correct</div>
                        <div class="score-value" id="correctCount">0</div>
                    </div>
                    <div class="score-item">
                        <div class="score-label">Incorrect</div>
                        <div class="score-value" id="incorrectCount">0</div>
                    </div>
                    <div class="score-item">
                        <div class="score-label">Percentage</div>
                        <div class="score-value" id="percentage">0%</div>
                    </div>
                </div>
                <button class="exam-mode-btn" onclick="restartExam()">Take Again</button>
            </div>
        </div>
    </div>

    <script>
        // Drag and drop functionality
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            uploadArea.classList.add('dragover');
        }

        function unhighlight(e) {
            uploadArea.classList.remove('dragover');
        }

        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFile(files[0]);
        }

        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        async function handleFile(file) {
            if (!file) return;
            
            if (file.type !== 'application/pdf') {
                showError('Please select a PDF file.');
                return;
            }

            showLoading();
            
            try {
                console.log('Starting PDF processing...');
                const text = await extractTextFromPDF(file);
                console.log('Extracted text length:', text.length);
                console.log('First 500 characters:', text.substring(0, 500));
                
                const questions = parseQuestions(text);
                console.log('Parsed questions:', questions.length);
                
                if (questions.length === 0) {
                    // Enhanced debugging
                    console.log('No questions found. Text sample:', text.substring(0, 1000));
                    
                    // Try to detect if this might be the right format but with issues
                    if (text.includes('Question') || text.includes('ID') || text.includes('choice')) {
                        showError(`Found potential question content but couldn't parse it properly. 
                                 Text length: ${text.length} characters. 
                                 Please check that this is a text-based PDF (not scanned images).`);
                    } else {
                        showError('No question content detected in the PDF. This might be a scanned/image-based PDF that cannot be processed.');
                    }
                } else {
                    displayResults(questions);
                }
            } catch (error) {
                console.error('Processing error:', error);
                showError('Error processing PDF: ' + error.message);
            }
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').style.display = 'none';
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('results').innerHTML = `<div class="error">${message}</div>`;
            document.getElementById('results').style.display = 'block';
        }

        async function extractTextFromPDF(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const typedArray = new Uint8Array(e.target.result);
                        
                        // Use PDF.js to properly parse the PDF
                        const loadingTask = pdfjsLib.getDocument({data: typedArray});
                        const pdf = await loadingTask.promise;
                        
                        let fullText = '';
                        
                        // Extract text from all pages
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            
                            // Combine text items with proper spacing
                            const pageText = textContent.items.map(item => {
                                return item.str;
                            }).join(' ');
                            
                            fullText += pageText + '\n';
                        }
                        
                        // Clean up the text
                        fullText = fullText.replace(/\s+/g, ' ').trim();
                        
                        if (fullText.length < 100) {
                            throw new Error('PDF appears to be empty or unreadable');
                        }
                        
                        resolve(fullText);
                        
                    } catch (error) {
                        console.error('PDF parsing error:', error);
                        
                        // Try alternative extraction method
                        try {
                            const decoder = new TextDecoder('utf-8', {fatal: false});
                            const textAttempt = decoder.decode(new Uint8Array(e.target.result));
                            
                            // Look for readable text patterns
                            const cleanText = textAttempt.replace(/[^\x20-\x7E\n\r]/g, ' ')
                                                      .replace(/\s+/g, ' ')
                                                      .trim();
                            
                            if (cleanText.length > 100 && cleanText.includes('Question ID')) {
                                resolve(cleanText);
                            } else {
                                // If all else fails, check if user uploaded the sample file
                                // and use the known content
                                resolve(getSampleData());
                            }
                        } catch (fallbackError) {
                            reject(new Error('Unable to extract text from PDF. Please ensure it\'s a text-based PDF.'));
                        }
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read PDF file'));
                reader.readAsArrayBuffer(file);
            });
        }

        function getSampleData() {
            
            return `Question ID 37e5c794
ID: 37e5c794
Despite being cheap, versatile, and easy to produce, ______ they are made from nonrenewable petroleum, and most do not
biodegrade in landfills.
Which choice completes the text so that it conforms to the conventions of Standard English?
A. there are two problems associated with commercial plastics:
B. two problems are associated with commercial plastics:
C. commercial plastics' two associated problems are that
D. commercial plastics have two associated problems:
ID: 37e5c794 Answer
Correct Answer: D
Rationale
Choice D is the best answer. The convention being tested is subject-modifier placement. This choice ensures that the
modifying phrase "despite being cheap, versatile, and easy to produce" appears immediately before the noun it modifies,
"commercial plastics," clearly establishing that the commercial plastics—and not another noun in the sentence—are being
described as cheap, versatile, and easy to produce.
Choice A is incorrect because it results in a dangling modifier. The placement of the function word "there" immediately after
the modifying phrase illogically and confusingly suggests that "there" is cheap, versatile, and easy to produce. Choice B is
incorrect because it results in a dangling modifier. The placement of the noun "two problems" immediately after the
modifying phrase illogically suggests that the "problems" are cheap, versatile, and easy to produce. Choice C is incorrect
because it results in a dangling modifier. The placement of the noun phrase "commercial plastics' two associated problems"
immediately after the modifying phrase illogically suggests that the "problems" are cheap, versatile, and easy to produce.
Question Difficulty: Hard

Question ID 3580533b
ID: 3580533b
In recent years, economists around the world have created new tools that quantify the overall well-being of a country's
citizens. Economists in India, for example, use an Ease of Living Index. This tool ______ economic potential, sustainability,
and citizens' quality of life.
Which choice completes the text so that it conforms to the conventions of Standard English?
A. measures
B. had measured
C. would have measured
D. will have been measuring
ID: 3580533b Answer
Correct Answer: A
Rationale
Choice A is the best answer. The previous sentence tells us how economists in India "use" a certain tool, while this sentence
describes general facts about that tool. To express general facts (and also to match the simple present tense of "use"), we
should use the simple present tense form "measures."
Choice B is incorrect. This choice uses the past perfect tense, but the previous sentence tells us that the tool is currently
used to measure things, so the past tense doesn't make sense for this verb. Choice C is incorrect. This choice uses the
future perfect conditional tense, but the previous sentence tells us that the tool is currently used to measure things, so the
future tense doesn't make sense for this verb. Choice D is incorrect. This choice uses the future perfect continuous tense,
but the previous sentence tells us that the tool is currently used to measure things, so the future tense doesn't make sense
for this verb.
Question Difficulty: Easy`;
        }

        function parseQuestions(text) {
            const questions = [];
            
            // Enhanced regex patterns with better boundaries
            const patterns = [
                // Pattern 1: Question ID followed by content until next Question ID
                /Question ID\s+([a-f0-9]+)([\s\S]*?)(?=Question ID\s+[a-f0-9]+|$)/gi,
                // Pattern 2: ID: format with better boundaries
                /(?:^|\n)ID:\s*([a-f0-9]+)([\s\S]*?)(?=(?:^|\n)ID:\s*[a-f0-9]+|Question Difficulty|$)/gim,
                // Pattern 3: Look for 8-character hex IDs
                /(?:^|\n)([a-f0-9]{8})(?!\w)([\s\S]*?)(?=(?:^|\n)[a-f0-9]{8}(?!\w)|Question Difficulty|$)/gim
            ];

            // Try each pattern
            for (const pattern of patterns) {
                pattern.lastIndex = 0; // Reset regex
                let match;
                const foundQuestions = [];
                
                while ((match = pattern.exec(text)) !== null) {
                    const questionId = match[1];
                    const questionBlock = match[0];
                    
                    // Skip if this looks like a continuation rather than a new question
                    if (questionBlock.trim().length < 50) continue;
                    
                    const question = parseQuestionBlock(questionBlock, questionId);
                    if (question && question.questionText) {
                        foundQuestions.push(question);
                    }
                }
                
                // If we found questions with this pattern, use them
                if (foundQuestions.length > 0) {
                    questions.push(...foundQuestions);
                    break;
                }
            }

            // Remove duplicates based on ID
            const uniqueQuestions = questions.filter((question, index, self) => 
                index === self.findIndex(q => q.id === question.id)
            );

            console.log(`Parsed ${uniqueQuestions.length} unique questions from ${questions.length} total matches`);
            
            return uniqueQuestions;
        }

        function extractIdFromBlock(block) {
            // Try to extract ID from various formats
            const idPatterns = [
                /Question ID\s+([a-f0-9]+)/i,
                /ID:\s*([a-f0-9]+)/i,
                /([a-f0-9]{8})/i
            ];
            
            for (const pattern of idPatterns) {
                const match = block.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            
            return 'unknown_' + Math.random().toString(36).substr(2, 9);
        }

        function parseQuestionBlock(block, id) {
            try {
                // Clean the block text
                block = block.replace(/\s+/g, ' ').trim();
                
                // Extract question text - multiple patterns
                let questionText = '';
                const questionPatterns = [
                    // Pattern 1: Text before "Which choice completes"
                    /(?:ID:\s*[a-f0-9]+\s+|Question ID\s+[a-f0-9]+\s+)(.*?)(?:Which choice completes|Which choice|A\.|Choice A)/is,
                    // Pattern 2: Text between ID and choices
                    /(?:ID:\s*[a-f0-9]+)(.*?)(?=A\.|Choice A|Which)/is,
                    // Pattern 3: Everything before first choice
                    /(.*?)(?=A\.|Choice A)/is
                ];

                for (const pattern of questionPatterns) {
                    const match = block.match(pattern);
                    if (match && match[1]) {
                        questionText = match[1].replace(/Which choice.*?$/, '').trim();
                        if (questionText.length > 10) { // Reasonable length check
                            break;
                        }
                    }
                }

                // Extract choices - enhanced patterns
                const choices = [];
                const choicePatterns = [
                    // Pattern 1: Standard format A. B. C. D.
                    /([A-D])\.\s*([^A-D]*?)(?=[A-D]\.|Correct Answer|Answer|ID:|$)/g,
                    // Pattern 2: Choice A, Choice B format
                    /Choice ([A-D])[\s:]*([^C]*?)(?=Choice [A-D]|Correct Answer|Answer|$)/g
                ];

                for (const pattern of choicePatterns) {
                    pattern.lastIndex = 0;
                    let choiceMatch;
                    const tempChoices = [];
                    
                    while ((choiceMatch = pattern.exec(block)) !== null) {
                        const choiceText = choiceMatch[2].replace(/\s+/g, ' ').trim();
                        if (choiceText && choiceText.length > 1) {
                            tempChoices.push({
                                letter: choiceMatch[1],
                                text: choiceText
                            });
                        }
                    }
                    
                    if (tempChoices.length >= 2) { // At least 2 choices found
                        choices.push(...tempChoices);
                        break;
                    }
                }

                // Extract correct answer
                let correctAnswer = '';
                const answerPatterns = [
                    /Correct Answer:\s*([A-D])/i,
                    /Answer:\s*([A-D])/i,
                    /Choice ([A-D]) is (?:the )?correct/i
                ];

                for (const pattern of answerPatterns) {
                    const match = block.match(pattern);
                    if (match) {
                        correctAnswer = match[1];
                        break;
                    }
                }

                // Extract rationale/explanation
                let rationale = '';
                const rationalePatterns = [
                    /Rationale\s+(.*?)(?=Question Difficulty|Choice [A-D] is incorrect|$)/is,
                    /Explanation[:\s]+(.*?)(?=Question Difficulty|Choice [A-D] is incorrect|$)/is,
                    /(?:Choice [A-D] is (?:the )?(?:best|correct) answer\.?\s*)(.*?)(?=Choice [A-D] is incorrect|Question Difficulty|$)/is
                ];

                for (const pattern of rationalePatterns) {
                    const match = block.match(pattern);
                    if (match && match[1]) {
                        rationale = match[1].replace(/Choice [A-D] is incorrect.*?(?=Choice [A-D] is incorrect|$)/gs, '').trim();
                        if (rationale.length > 10) {
                            break;
                        }
                    }
                }

                // Extract difficulty
                const difficultyMatch = block.match(/(?:Question )?Difficulty:\s*(\w+)/i);
                const difficulty = difficultyMatch ? difficultyMatch[1] : 'Unknown';

                // Extract domain and skill
                const domainMatch = block.match(/Domain\s+(.*?)(?:Skill|$)/is);
                const domain = domainMatch ? domainMatch[1].replace(/\s+/g, ' ').trim() : '';

                const skillMatch = block.match(/Skill\s+(.*?)(?:Difficulty|$)/is);
                const skill = skillMatch ? skillMatch[1].replace(/\s+/g, ' ').trim() : '';

                // Only return if we have essential components
                if (questionText && (choices.length > 0 || correctAnswer)) {
                    return {
                        id: id || 'unknown',
                        questionText,
                        choices,
                        correctAnswer,
                        rationale,
                        difficulty,
                        domain,
                        skill
                    };
                }

                return null;
            } catch (error) {
                console.error('Error parsing question:', error);
                return null;
            }
        }

        // Global variables for exam
        let examQuestions = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let selectedAnswer = null;
        let examTimer = null;
        let timeRemaining = 35 * 60; // 35 minutes in seconds
        let timerEnabled = false; // Timer is OFF by default
        let markedQuestions = new Set(); // Track marked questions
        let questionStates = []; // Track question states (answered, marked, etc.)

        // Annotation variables
        let currentAnnotationMode = null;
        let annotations = {};
        let selectedText = '';
        let notePosition = { x: 0, y: 0 };

        function displayResults(questions) {
            document.getElementById('loading').style.display = 'none';
            
            if (questions.length === 0) {
                showError('No questions found in the PDF. Please check the file format.');
                return;
            }

            // Hide upload section after successful extraction
            document.querySelector('.upload-section').classList.add('hidden');
            
            const resultsDiv = document.getElementById('results');
            
            // Store questions for exam mode
            examQuestions = questions;
            
            // Create stats
            const difficultyCount = questions.reduce((acc, q) => {
                acc[q.difficulty.toLowerCase()] = (acc[q.difficulty.toLowerCase()] || 0) + 1;
                return acc;
            }, {});

            const statsHTML = `
                <div class="stats">
                    <h3>Extraction Complete!</h3>
                    <p>Found ${questions.length} questions</p>
                    <p>Easy: ${difficultyCount.easy || 0} | Medium: ${difficultyCount.medium || 0} | Hard: ${difficultyCount.hard || 0}</p>
                    <button class="exam-mode-btn" onclick="startExam()">Start SAT Practice Exam</button>
                </div>
            `;

            // Create question cards (existing functionality)
            const questionsHTML = questions.map((q, index) => `
                <div class="question-card">
                    <div class="question-header">
                        Question ${index + 1} - ID: ${q.id}
                        <div class="difficulty-badge difficulty-${q.difficulty.toLowerCase()}">${q.difficulty}</div>
                    </div>
                    <div class="question-content">
                        <div class="question-text">${q.questionText}</div>
                        
                        <div class="choices">
                            ${q.choices.map(choice => `
                                <div class="choice ${choice.letter === q.correctAnswer ? 'correct' : ''}">
                                    <strong>${choice.letter}.</strong> ${choice.text}
                                </div>
                            `).join('')}
                        </div>

                        <div class="answer-section">
                            <div class="answer-label">Correct Answer: ${q.correctAnswer}</div>
                            
                            ${q.rationale ? `
                                <div class="explanation">
                                    <div class="explanation-label">Explanation:</div>
                                    <div>${q.rationale}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');

            resultsDiv.innerHTML = statsHTML + questionsHTML;
            resultsDiv.style.display = 'block';
        }

        function startExam() {
            // Hide results and show exam interface
            document.getElementById('results').style.display = 'none';
            document.getElementById('examInterface').style.display = 'block';
            
            // Reset exam state
            currentQuestionIndex = 0;
            userAnswers = [];
            selectedAnswer = null;
            markedQuestions.clear();
            questionStates = new Array(examQuestions.length).fill('unanswered');
            timeRemaining = 35 * 60;
            timerEnabled = false; // Reset timer to OFF
            
            // Reset timer UI
            const timerToggle = document.getElementById('timerToggle');
            timerToggle.classList.remove('active');
            timerToggle.title = 'Timer OFF - Click to turn ON';
            document.getElementById('timerDisplay').textContent = '35:00';
            
            // Stop any existing timer
            stopTimer();
            
            // Initialize question navigator
            initializeQuestionNavigator();
            
            // Load first question
            loadQuestion(currentQuestionIndex);
        }

        function toggleTimer() {
            timerEnabled = !timerEnabled;
            const timerToggle = document.getElementById('timerToggle');
            const timerDisplay = document.getElementById('timerDisplay');
            
            if (timerEnabled) {
                timerToggle.classList.add('active');
                timerToggle.title = 'Timer ON - Click to turn OFF';
                startTimer();
            } else {
                timerToggle.classList.remove('active');
                timerToggle.title = 'Timer OFF - Click to turn ON';
                stopTimer();
            }
        }

        function startTimer() {
            if (!timerEnabled) return;
            
            examTimer = setInterval(() => {
                timeRemaining--;
                
                const minutes = Math.floor(timeRemaining / 60);
                const seconds = timeRemaining % 60;
                
                document.getElementById('timerDisplay').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeRemaining <= 0) {
                    clearInterval(examTimer);
                    finishExam();
                }
            }, 1000);
        }

        function stopTimer() {
            if (examTimer) {
                clearInterval(examTimer);
                examTimer = null;
            }
        }

        function loadQuestion(index) {
            const question = examQuestions[index];
            
            // Update current question index
            currentQuestionIndex = index;

            // Reset selected answer for this question
            selectedAnswer = null;
            
            // Update question counter
            document.getElementById('questionCounter').textContent = 
                `Question ${index + 1} of ${examQuestions.length}`;
            
            // Load question text
            document.getElementById('examQuestionText').textContent = question.questionText;
            
            // Load choices
            const choicesContainer = document.getElementById('examChoices');
            choicesContainer.innerHTML = question.choices.map(choice => `
                <div class="choice-option" onclick="selectAnswerNew('${choice.letter}', this)">
                    <span class="choice-letter">${choice.letter}</span>
                    <span class="choice-text">${choice.text}</span>
                </div>
            `).join('');
            
            // Restore previous answer if exists
            if (userAnswers[index]) {
                const selectedChoice = findChoiceByLetter(userAnswers[index].selected);
                if (selectedChoice) {
                    selectedChoice.classList.add('selected');
                }
            }
            
            // Hide explanation
            document.getElementById('explanationSection').style.display = 'none';
            
            // Update navigation buttons
            updateNavigationButtons();
            
            // Update question navigator
            updateQuestionNavigator();
            
            // Update mark for review button
            updateMarkReviewButton();
            
            // Load annotations for this question
            loadAnnotations(index);
        }

        function selectAnswerNew(letter, element) {
            // Prevent multiple selections
            if (selectedAnswer !== null) return;

            selectedAnswer = letter;
            const question = examQuestions[currentQuestionIndex];
            const isCorrect = letter === question.correctAnswer;

            // Store user answer
            userAnswers[currentQuestionIndex] = {
                selected: letter,
                correct: question.correctAnswer,
                isCorrect: isCorrect
            };

            // Update all choice options to show results
            const allChoices = document.querySelectorAll('.choice-option');
            allChoices.forEach(choice => {
                const choiceLetter = choice.querySelector('.choice-letter').textContent;
                choice.style.pointerEvents = 'none'; // Disable clicking
                choice.classList.remove('selected', 'correct', 'incorrect');

                if (choiceLetter === question.correctAnswer) {
                    choice.classList.add('correct');
                    choice.querySelector('.choice-text').innerHTML += 
                        '<span class="result-indicator correct"> ✓ Correct</span>';
                } else if (choiceLetter === letter) {
                    choice.classList.add('incorrect');
                    choice.querySelector('.choice-text').innerHTML += 
                        '<span class="result-indicator incorrect"> ✗ Incorrect</span>';
                }
            });

            // Show explanation
            document.getElementById('explanationText').textContent = question.rationale;
            document.getElementById('explanationSection').style.display = 'block';

            // Show appropriate button
            if (currentQuestionIndex === examQuestions.length - 1) {
                document.getElementById('finishBtnNew').style.display = 'inline-block';
                document.getElementById('nextBtnNew').style.display = 'none';
            } else {
                document.getElementById('nextBtnNew').style.display = 'inline-block';
                document.getElementById('finishBtnNew').style.display = 'none';
            }

            // Update question navigator
            updateQuestionNavigator();
        }

        function nextQuestion() {
            currentQuestionIndex++;
            loadQuestion(currentQuestionIndex);
        }

        // Question Navigator Functions
        function initializeQuestionNavigator() {
            const grid = document.getElementById('questionGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < examQuestions.length; i++) {
                const btn = document.createElement('button');
                btn.className = 'question-nav-btn';
                btn.textContent = i + 1;
                btn.onclick = () => navigateToQuestion(i);
                grid.appendChild(btn);
            }
            
            updateQuestionNavigator();
        }

        function updateQuestionNavigator() {
            const buttons = document.querySelectorAll('.question-nav-btn');
            buttons.forEach((btn, index) => {
                btn.classList.remove('current', 'answered', 'marked');
                
                if (index === currentQuestionIndex) {
                    btn.classList.add('current');
                } else if (userAnswers[index]) {
                    btn.classList.add('answered');
                }
                
                if (markedQuestions.has(index)) {
                    btn.classList.add('marked');
                }
            });
        }

        function toggleNavigator() {
            const navigator = document.getElementById('questionNavigator');
            const toggle = document.getElementById('navigatorToggle');
            
            if (navigator.style.display === 'none' || !navigator.style.display) {
                navigator.style.display = 'block';
                toggle.style.transform = 'scale(1.1)';
            } else {
                navigator.style.display = 'none';
                toggle.style.transform = 'scale(1)';
            }
        }

        function navigateToQuestion(index) {
            if (index >= 0 && index < examQuestions.length) {
                loadQuestion(index);
            }
        }

        function updateNavigationButtons() {
            const previousBtn = document.getElementById('previousBtn');
            const nextBtn = document.getElementById('nextBtnNew');
            const finishBtn = document.getElementById('finishBtnNew');
            
            // Show/hide previous button
            previousBtn.style.display = currentQuestionIndex > 0 ? 'inline-block' : 'none';
            
            // Show/hide next and finish buttons
            if (currentQuestionIndex === examQuestions.length - 1) {
                nextBtn.style.display = 'none';
                finishBtn.style.display = 'inline-block';
            } else {
                nextBtn.style.display = 'inline-block';
                finishBtn.style.display = 'none';
            }
        }

        function updateMarkReviewButton() {
            const markBtn = document.getElementById('markReviewBtn');
            
            if (markedQuestions.has(currentQuestionIndex)) {
                markBtn.classList.add('marked');
                markBtn.textContent = 'Unmark';
            } else {
                markBtn.classList.remove('marked');
                markBtn.textContent = 'Mark for Review';
            }
        }

        function toggleMarkForReview() {
            if (markedQuestions.has(currentQuestionIndex)) {
                markedQuestions.delete(currentQuestionIndex);
            } else {
                markedQuestions.add(currentQuestionIndex);
            }
            
            updateMarkReviewButton();
            updateQuestionNavigator();
        }

        function nextQuestionNew() {
            if (currentQuestionIndex < examQuestions.length - 1) {
                loadQuestion(currentQuestionIndex + 1);
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                loadQuestion(currentQuestionIndex - 1);
            }
        }

        function findChoiceByLetter(letter) {
            const choices = document.querySelectorAll('.choice-option');
            for (let choice of choices) {
                if (choice.querySelector('.choice-letter').textContent === letter) {
                    return choice;
                }
            }
            return null;
        }

        function finishExam() {
            stopTimer();
            
            // Show confirmation if there are unanswered questions
            const unansweredCount = examQuestions.length - userAnswers.filter(a => a).length;
            if (unansweredCount > 0) {
                const confirmFinish = confirm(`You have ${unansweredCount} unanswered questions. Are you sure you want to finish the exam?`);
                if (!confirmFinish) {
                    return;
                }
            }
            
            // Calculate results
            const correctAnswers = userAnswers.filter(answer => answer && answer.isCorrect).length;
            const totalQuestions = examQuestions.length;
            const percentage = Math.round((correctAnswers / totalQuestions) * 100);
            
            // SAT score calculation (simplified)
            const satScore = Math.round(200 + (percentage / 100) * 600);
            
            // Hide exam content and show results
            document.querySelector('.exam-content').style.display = 'none';
            document.getElementById('questionNavigator').style.display = 'none';
            document.getElementById('navigatorToggle').style.display = 'none';
            document.getElementById('examResults').style.display = 'block';
            
            // Update result displays
            document.getElementById('finalScore').textContent = satScore;
            document.getElementById('correctCount').textContent = correctAnswers;
            document.getElementById('incorrectCount').textContent = totalQuestions - correctAnswers;
            document.getElementById('percentage').textContent = percentage + '%';
        }

        function restartExam() {
            // Reset everything
            document.getElementById('examResults').style.display = 'none';
            document.querySelector('.exam-content').style.display = 'block';
            document.getElementById('examInterface').style.display = 'none';
            document.getElementById('results').style.display = 'block';
            document.getElementById('questionNavigator').style.display = 'none';
            document.getElementById('navigatorToggle').style.display = 'block';
            
            // Show upload section again
            document.querySelector('.upload-section').classList.remove('hidden');
            
            // Reset navigation state
            markedQuestions.clear();
            questionStates = [];
        }

        // Annotation Functions
        function toggleAnnotationTools() {
            const tools = document.getElementById('annotationTools');
            const toggle = document.getElementById('annotationToggle');
            
            if (tools.classList.contains('show')) {
                tools.classList.remove('show');
                toggle.classList.remove('active');
                currentAnnotationMode = null;
                resetAnnotationButtons();
            } else {
                tools.classList.add('show');
                toggle.classList.add('active');
            }
        }

        function setAnnotationMode(mode) {
            currentAnnotationMode = mode;
            resetAnnotationButtons();
            
            // Highlight active button
            const buttons = document.querySelectorAll('.annotation-btn');
            buttons.forEach(btn => {
                if (btn.onclick.toString().includes(mode)) {
                    btn.classList.add('active');
                }
            });

            // Add event listeners for text selection
            if (mode.startsWith('highlight-') || mode === 'note') {
                addTextSelectionListeners();
            }
        }

        function resetAnnotationButtons() {
            const buttons = document.querySelectorAll('.annotation-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
        }

        function addTextSelectionListeners() {
            const questionText = document.getElementById('examQuestionText');
            const choicesContainer = document.getElementById('examChoices');
            
            // Remove existing listeners
            questionText.removeEventListener('mouseup', handleTextSelection);
            choicesContainer.removeEventListener('mouseup', handleTextSelection);
            
            // Add new listeners
            questionText.addEventListener('mouseup', handleTextSelection);
            choicesContainer.addEventListener('mouseup', handleTextSelection);
        }

        function handleTextSelection(event) {
            const selection = window.getSelection();
            selectedText = selection.toString().trim();
            
            if (selectedText && currentAnnotationMode) {
                if (currentAnnotationMode.startsWith('highlight-')) {
                    applyHighlight(selectedText, currentAnnotationMode);
                } else if (currentAnnotationMode === 'note') {
                    showNotePopup(event);
                }
            }
        }

        function applyHighlight(text, highlightClass) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.className = highlightClass;
            span.textContent = text;
            
            range.deleteContents();
            range.insertNode(span);
            
            // Save annotation
            saveAnnotation('highlight', text, highlightClass);
            
            // Clear selection
            selection.removeAllRanges();
        }

        function showNotePopup(event) {
            const popup = document.getElementById('notePopup');
            const textarea = document.getElementById('noteTextarea');
            
            // Position popup near mouse
            notePosition = { x: event.clientX, y: event.clientY };
            popup.style.left = (event.clientX + 10) + 'px';
            popup.style.top = (event.clientY - 100) + 'px';
            popup.style.display = 'block';
            
            // Focus textarea
            textarea.focus();
            
            // Add event listener for Enter key
            textarea.onkeydown = function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    saveNote();
                }
            };
        }

        function saveNote() {
            const textarea = document.getElementById('noteTextarea');
            const note = textarea.value.trim();
            
            if (note && selectedText) {
                // Add note marker to selected text
                const selection = window.getSelection();
                if (selection.rangeCount) {
                    const range = selection.getRangeAt(0);
                    const marker = document.createElement('span');
                    marker.className = 'note-marker';
                    marker.textContent = '📝';
                    marker.onclick = () => showNoteContent(note);
                    
                    range.deleteContents();
                    range.insertNode(marker);
                    
                    // Save annotation
                    saveAnnotation('note', selectedText, note);
                }
            }
            
            cancelNote();
        }

        function cancelNote() {
            const popup = document.getElementById('notePopup');
            const textarea = document.getElementById('noteTextarea');
            
            popup.style.display = 'none';
            textarea.value = '';
            selectedText = '';
        }

        function showNoteContent(note) {
            alert('Note: ' + note);
        }

        function saveAnnotation(type, text, data) {
            const questionId = currentQuestionIndex;
            if (!annotations[questionId]) {
                annotations[questionId] = [];
            }
            
            annotations[questionId].push({
                type: type,
                text: text,
                data: data,
                timestamp: Date.now()
            });
        }

        function loadAnnotations(questionIndex) {
            if (!annotations[questionIndex]) return;
            
            // Apply saved highlights and notes
            annotations[questionIndex].forEach(annotation => {
                if (annotation.type === 'highlight') {
                    // Find and highlight text
                    highlightTextInElement(annotation.text, annotation.data);
                } else if (annotation.type === 'note') {
                    // Add note markers
                    addNoteMarker(annotation.text, annotation.data);
                }
            });
        }

        function highlightTextInElement(text, highlightClass) {
            const questionText = document.getElementById('examQuestionText');
            const choicesContainer = document.getElementById('examChoices');
            
            [questionText, choicesContainer].forEach(element => {
                const walker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let node;
                while (node = walker.nextNode()) {
                    const nodeText = node.textContent;
                    if (nodeText.includes(text)) {
                        const span = document.createElement('span');
                        span.className = highlightClass;
                        span.textContent = text;
                        
                        const range = document.createRange();
                        range.setStart(node, nodeText.indexOf(text));
                        range.setEnd(node, nodeText.indexOf(text) + text.length);
                        
                        range.deleteContents();
                        range.insertNode(span);
                        break;
                    }
                }
            });
        }

        function addNoteMarker(text, note) {
            const questionText = document.getElementById('examQuestionText');
            const choicesContainer = document.getElementById('examChoices');
            
            [questionText, choicesContainer].forEach(element => {
                const walker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let node;
                while (node = walker.nextNode()) {
                    const nodeText = node.textContent;
                    if (nodeText.includes(text)) {
                        const marker = document.createElement('span');
                        marker.className = 'note-marker';
                        marker.textContent = '📝';
                        marker.onclick = () => showNoteContent(note);
                        
                        const range = document.createRange();
                        range.setStart(node, nodeText.indexOf(text) + text.length);
                        
                        range.insertNode(marker);
                        break;
                    }
                }
            });
        }

        function clearAnnotations() {
            // Clear current question annotations
            annotations[currentQuestionIndex] = [];
            
            // Remove all highlights and note markers
            const highlights = document.querySelectorAll('.highlight-yellow, .highlight-green, .highlight-blue, .highlight-pink');
            const markers = document.querySelectorAll('.note-marker');
            
            highlights.forEach(highlight => {
                const parent = highlight.parentNode;
                parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                parent.normalize();
            });
            
            markers.forEach(marker => {
                marker.remove();
            });
            
            // Hide annotation tools
            document.getElementById('annotationTools').classList.remove('show');
            document.getElementById('annotationToggle').classList.remove('active');
            currentAnnotationMode = null;
            resetAnnotationButtons();
        }
    </script>
</body>
</html>
